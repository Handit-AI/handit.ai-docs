---
title: 'Node Tracing Wrapper'
sidebarTitle: 'Node Tracing Wrapper'
---

import { Callout } from "nextra/components"
import { Steps } from "nextra/components"
import { Tabs } from "nextra/components"

# Node Tracing Wrapper

The Node Tracing Wrapper provides a flexible way to trace function executions when you need more control over the tracing process. Unlike the decorator approach, the wrapper allows you to trace functions dynamically and handle complex scenarios with custom logic.

<Callout type="info">
  Node Tracing Wrapper is ideal for scenarios where you need to trace functions dynamically or when you don't have direct control over the function definition.
</Callout>

## How It Works

Node Tracing Wrapper creates a trace for function executions by wrapping them, allowing you to:

- Trace functions dynamically
- Add custom logic before and after execution
- Handle complex error scenarios
- Integrate with existing code without modifications

## Implementation

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="node_wrapper.py"
    from handit_service import tracker

    # Basic usage with async function
    async def fetch_documents(query: str) -> list[str]:
        # Your vector search implementation
        return docs

    # Wrap the function for tracing
    traced_fetch = tracker.trace_agent_node_func(
        fetch_documents,
        key="vector-search"
    )

    # Basic usage with sync function
    def process_text(text: str) -> str:
        # Your text processing implementation
        return processed_text

    # Wrap the function for tracing
    traced_process = tracker.trace_agent_node_func_sync(
        process_text,
        key="text-processor"
    )

    # With error handling
    async def run_inference(prompt: str) -> str:
        try:
            result = await model.generate(prompt)
            return result
        except Exception as e:
            logger.error(f"Inference error: {e}")
            raise

    # Wrap with error handling
    traced_inference = tracker.trace_agent_node_func(
        run_inference,
        key="model-inference"
    )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="node_wrapper.js"
    const { traceAgentNode } = require('handit-service');

    // Basic usage with async function
    const fetchDocuments = async (query) => {
        // Your vector search implementation
        return docs;
    };

    // Wrap the function for tracing
    const tracedFetch = traceAgentNode({
        agentNodeId: 'vector-search',
        callback: fetchDocuments
    });

    // Basic usage with sync function
    const processText = (text) => {
        // Your text processing implementation
        return processedText;
    };

    // Wrap the function for tracing
    const tracedProcess = traceAgentNode({
        agentNodeId: 'text-processor',
        callback: processText
    });

    // With error handling
    const runInference = async (prompt) => {
        try {
            const result = await model.generate(prompt);
            return result;
        } catch (error) {
            logger.error(`Inference error: ${error}`);
            throw error;
        }
    };

    // Wrap with error handling
    const tracedInference = traceAgentNode({
        agentNodeId: 'model-inference',
        callback: runInference
    });
    ```
  </Tabs.Tab>
</Tabs>

## Common Use Cases

### 1. Dynamic Function Tracing

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="dynamic_tracing.py"
    from handit_service import tracker
    import logging
    from typing import Any, Callable, Dict, List, Optional

    # Dynamic function tracing with detailed error handling
    def trace_dynamic_function(func: Callable, key: Optional[str] = None) -> Callable:
        """
        Dynamically trace any function based on runtime conditions.
        Includes detailed error handling and logging.
        """
        if key is None:
            key = func.__name__

        async def wrapped_func(*args: Any, **kwargs: Any) -> Any:
            try:
                return await tracker.trace_agent_node_func(
                    func,
                    *args,
                    key=key,
                    **kwargs
                )
            except Exception as e:
                logging.error(f"Error in traced function {key}: {str(e)}")
                raise

        return wrapped_func

    # Usage examples
    async def process_data(data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process data with validation and transformation.
        """
        # Validate input
        if not data:
            raise ValueError("Empty data provided")
        
        # Process data
        result = await processor.process(data)
        return result

    # Dynamically trace based on conditions
    if should_trace:
        traced_process = trace_dynamic_function(
            process_data,
            key="dynamic-processor"
        )

    # Example with multiple functions
    async def analyze_text(text: str) -> Dict[str, Any]:
        return await analyzer.process(text)

    async def generate_summary(content: str) -> str:
        return await summarizer.generate(content)

    # Create traced versions
    traced_analyzer = trace_dynamic_function(analyze_text, "text-analyzer")
    traced_summarizer = trace_dynamic_function(generate_summary, "text-summarizer")
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="dynamic_tracing.js"
    const { traceAgentNode } = require('handit-service');
    const logger = require('./logger');

    // Dynamic function tracing with detailed error handling
    const traceDynamicFunction = (func, key = null) => {
        const nodeId = key || func.name;
        
        return traceAgentNode({
            agentNodeId: nodeId,
            callback: async (...args) => {
                try {
                    return await func(...args);
                } catch (error) {
                    logger.error(`Error in traced function ${nodeId}: ${error.message}`);
                    throw error;
                }
            }
        });
    };

    // Usage examples
    const processData = async (data) => {
        // Validate input
        if (!data) {
            throw new Error('Empty data provided');
        }
        
        // Process data
        const result = await processor.process(data);
        return result;
    };

    // Dynamically trace based on conditions
    const tracedProcess = shouldTrace
        ? traceDynamicFunction(processData, 'dynamic-processor')
        : processData;

    // Example with multiple functions
    const analyzeText = async (text) => {
        return await analyzer.process(text);
    };

    const generateSummary = async (content) => {
        return await summarizer.generate(content);
    };

    // Create traced versions
    const tracedAnalyzer = traceDynamicFunction(analyzeText, 'text-analyzer');
    const tracedSummarizer = traceDynamicFunction(generateSummary, 'text-summarizer');
    ```
  </Tabs.Tab>
</Tabs>

### 2. Batch Processing

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="batch_processing.py"
    from handit_service import tracker
    from typing import List, Dict, Any, Callable
    import asyncio
    import logging

    # Batch processing with tracing and concurrency
    async def process_batch(
        items: List[Dict[str, Any]],
        processor_func: Callable,
        batch_size: int = 10,
        max_concurrent: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Process a batch of items with tracing and controlled concurrency.
        """
        traced_processor = tracker.trace_agent_node_func(
            processor_func,
            key="batch-processor"
        )
        
        results = []
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            # Process batch with controlled concurrency
            batch_results = await asyncio.gather(
                *[traced_processor(item) for item in batch],
                return_exceptions=True
            )
            
            # Handle results and errors
            for result in batch_results:
                if isinstance(result, Exception):
                    logging.error(f"Error processing item: {str(result)}")
                    results.append({"error": str(result)})
                else:
                    results.append(result)
                    
        return results

    # Usage examples
    async def process_item(item: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process a single item with validation and transformation.
        """
        # Validate item
        if not item.get("id"):
            raise ValueError("Item missing required 'id' field")
            
        # Process item
        result = await processor.transform(item)
        return result

    # Process batch with tracing
    items = [
        {"id": "1", "data": "value1"},
        {"id": "2", "data": "value2"},
        # ... more items
    ]
    
    results = await process_batch(
        items,
        process_item,
        batch_size=10,
        max_concurrent=5
    )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="batch_processing.js"
    const { traceAgentNode } = require('handit-service');
    const logger = require('./logger');

    // Batch processing with tracing and concurrency
    const processBatch = async (items, processorFunc, batchSize = 10, maxConcurrent = 5) => {
        const tracedProcessor = traceAgentNode({
            agentNodeId: 'batch-processor',
            callback: processorFunc
        });
        
        const results = [];
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            // Process batch with controlled concurrency
            const batchResults = await Promise.allSettled(
                batch.map(item => tracedProcessor(item))
            );
            
            // Handle results and errors
            batchResults.forEach(result => {
                if (result.status === 'rejected') {
                    logger.error(`Error processing item: ${result.reason}`);
                    results.push({ error: result.reason.message });
                } else {
                    results.push(result.value);
                }
            });
        }
        return results;
    };

    // Usage examples
    const processItem = async (item) => {
        // Validate item
        if (!item.id) {
            throw new Error("Item missing required 'id' field");
        }
        
        // Process item
        const result = await processor.transform(item);
        return result;
    };

    // Process batch with tracing
    const items = [
        { id: "1", data: "value1" },
        { id: "2", data: "value2" },
        // ... more items
    ];
    
    const results = await processBatch(
        items,
        processItem,
        10,  // batchSize
        5    // maxConcurrent
    );
    ```
  </Tabs.Tab>
</Tabs>

### 3. Conditional Tracing

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="conditional_tracing.py"
    from handit_service import tracker
    from typing import Callable, Any, Optional
    import os
    import logging

    # Conditional tracing based on environment and configuration
    def get_traced_function(
        func: Callable,
        key: str,
        force_trace: bool = False
    ) -> Callable:
        """
        Get traced or untraced function based on environment and configuration.
        """
        # Check if tracing should be enabled
        should_trace = (
            force_trace or
            os.getenv("ENABLE_TRACING", "false").lower() == "true" or
            is_production()
        )

        if should_trace:
            logging.info(f"Enabling tracing for function: {key}")
            return tracker.trace_agent_node_func(
                func,
                key=key
            )
        return func

    # Usage examples
    async def analyze_data(data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze data with validation and processing.
        """
        # Validate input
        if not data:
            raise ValueError("Empty data provided")
            
        # Process data
        result = await analyzer.process(data)
        return result

    # Get appropriate function based on environment
    traced_analyzer = get_traced_function(
        analyze_data,
        key="data-analyzer",
        force_trace=True  # Force tracing regardless of environment
    )

    # Example with multiple functions
    async def process_text(text: str) -> str:
        return await processor.process(text)

    async def generate_report(data: Dict[str, Any]) -> str:
        return await reporter.generate(data)

    # Create traced versions based on environment
    traced_processor = get_traced_function(process_text, "text-processor")
    traced_reporter = get_traced_function(generate_report, "report-generator")
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="conditional_tracing.js"
    const { traceAgentNode } = require('handit-service');
    const logger = require('./logger');

    // Conditional tracing based on environment and configuration
    const getTracedFunction = (func, key, forceTrace = false) => {
        // Check if tracing should be enabled
        const shouldTrace = 
            forceTrace ||
            process.env.ENABLE_TRACING === 'true' ||
            isProduction();

        if (shouldTrace) {
            logger.info(`Enabling tracing for function: ${key}`);
            return traceAgentNode({
                agentNodeId: key,
                callback: func
            });
        }
        return func;
    };

    // Usage examples
    const analyzeData = async (data) => {
        // Validate input
        if (!data) {
            throw new Error('Empty data provided');
        }
        
        // Process data
        const result = await analyzer.process(data);
        return result;
    };

    // Get appropriate function based on environment
    const tracedAnalyzer = getTracedFunction(
        analyzeData,
        'data-analyzer',
        true  // Force tracing regardless of environment
    );

    // Example with multiple functions
    const processText = async (text) => {
        return await processor.process(text);
    };

    const generateReport = async (data) => {
        return await reporter.generate(data);
    };

    // Create traced versions based on environment
    const tracedProcessor = getTracedFunction(processText, 'text-processor');
    const tracedReporter = getTracedFunction(generateReport, 'report-generator');
    ```
  </Tabs.Tab>
</Tabs>

## Best Practices

1. **Function Wrapping**
   - Wrap functions at the appropriate level
   - Consider performance implications
   - Handle both sync and async functions

2. **Error Handling**
   - Implement proper error boundaries
   - Capture and propagate errors
   - Include error context in traces

3. **Performance Monitoring**
   - Track execution time
   - Monitor resource usage
   - Identify bottlenecks

4. **Dynamic Tracing**
   - Use meaningful keys
   - Consider environment conditions
   - Handle edge cases

<Callout type="warning">
  Always implement proper error handling in your wrapped functions to ensure errors are properly tracked and reported.
</Callout>

## Advanced Usage

### 1. Custom Context

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="custom_context.py"
    # Custom context with tracing
    async def process_with_context(data: dict, context: dict) -> dict:
        """
        Process data with custom context information.
        """
        # Add context to processing
        result = await processor.process(data, context)
        return result

    # Wrap with custom context
    traced_process = tracker.trace_agent_node_func(
        process_with_context,
        key="context-processor"
    )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="custom_context.js"
    // Custom context with tracing
    const processWithContext = async (data, context) => {
        // Add context to processing
        const result = await processor.process(data, context);
        return result;
    };

    // Wrap with custom context
    const tracedProcess = traceAgentNode({
        agentNodeId: 'context-processor',
        callback: processWithContext
    });
    ```
  </Tabs.Tab>
</Tabs>

### 2. Middleware Integration

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="middleware.py"
    # Middleware with tracing
    async def tracing_middleware(func, key: str):
        """
        Middleware that adds tracing to any function.
        """
        traced_func = tracker.trace_agent_node_func(
            func,
            key=key
        )
        
        async def middleware(*args, **kwargs):
            # Pre-processing
            result = await traced_func(*args, **kwargs)
            # Post-processing
            return result
            
        return middleware

    # Usage
    async def handle_request(request: dict) -> dict:
        return await processor.process(request)

    # Add tracing middleware
    traced_handler = await tracing_middleware(
        handle_request,
        key="request-handler"
    )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="middleware.js"
    // Middleware with tracing
    const tracingMiddleware = (func, key) => {
        const tracedFunc = traceAgentNode({
            agentNodeId: key,
            callback: func
        });
        
        return async (...args) => {
            // Pre-processing
            const result = await tracedFunc(...args);
            // Post-processing
            return result;
        };
    };

    // Usage
    const handleRequest = async (request) => {
        return await processor.process(request);
    };

    // Add tracing middleware
    const tracedHandler = tracingMiddleware(handleRequest, 'request-handler');
    ```
  </Tabs.Tab>
</Tabs>

<Callout type="info">
  Node Tracing Wrapper is particularly useful for dynamic tracing scenarios and when you need to add tracing to existing code without modifying function definitions.
</Callout>

<Callout type="success">
  By using Node Tracing Wrapper effectively, you can add tracing to your application with minimal code changes and maximum flexibility.
</Callout>
