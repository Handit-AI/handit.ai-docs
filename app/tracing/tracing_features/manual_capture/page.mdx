---
title: 'Manual Capture'
sidebarTitle: 'Manual Capture'
---

import { Callout } from "nextra/components"
import { Steps } from "nextra/components"
import { Tabs } from "nextra/components"

# Manual Capture

Manual Capture is your Swiss Army knife for custom tracking needs. When you need complete control over what and how you track, this flexible tool has got you covered. It's perfect for scenarios where automatic tracing isn't possible or sufficient.

<Callout type="info">
  Manual Capture allows you to explicitly track any event or operation, giving you full control over what data is captured and when.
</Callout>

## How It Works

Manual Capture provides direct control over tracking by:

- Capturing custom events and operations
- Tracking batch processing results
- Monitoring ML pipeline outputs
- Recording custom metrics and data

## Implementation

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="manual_capture.py"
    from handit_service import tracker
    from typing import Dict, Any, Optional
    import logging

    # Basic usage with custom event
    tracker.capture_model(
        model_id="custom-event",
        request_body={"user_id": 123},
        response_body={"status": "success"}
    )

    # Usage with ML pipeline results
    async def process_batch(items: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        try:
            results = []
            for item in items:
                # Process item
                result = process_item(item)
                results.append(result)
                
                # Track individual result
                tracker.capture_model(
                    model_id="batch-processor",
                    request_body=item,
                    response_body=result
                )
            
            # Track batch summary
            tracker.capture_model(
                model_id="batch-summary",
                request_body={"total_items": len(items)},
                response_body={"processed_items": len(results)}
            )
            
            return results
        except Exception as e:
            logging.error(f"Batch processing error: {str(e)}")
            raise

    # Example with custom metrics
    def track_performance_metrics(
        operation: str,
        metrics: Dict[str, Any]
    ) -> None:
        tracker.capture_model(
            model_id=f"performance-{operation}",
            request_body={"operation": operation},
            response_body=metrics
        )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="manual_capture.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // Basic usage with custom event
    captureModel({
        modelId: 'custom-event',
        requestBody: { userId: 123 },
        responseBody: { status: 'success' }
    });

    // Usage with ML pipeline results
    const processBatch = async (items) => {
        try {
            const results = [];
            for (const item of items) {
                // Process item
                const result = processItem(item);
                results.push(result);
                
                // Track individual result
                await captureModel({
                    modelId: 'batch-processor',
                    requestBody: item,
                    responseBody: result
                });
            }
            
            // Track batch summary
            await captureModel({
                modelId: 'batch-summary',
                requestBody: { totalItems: items.length },
                responseBody: { processedItems: results.length }
            });
            
            return results;
        } catch (error) {
            logger.error(`Batch processing error: ${error.message}`);
            throw error;
        }
    };

    // Example with custom metrics
    const trackPerformanceMetrics = (operation, metrics) => {
        captureModel({
            modelId: `performance-${operation}`,
            requestBody: { operation },
            responseBody: metrics
        });
    };
    ```
  </Tabs.Tab>
</Tabs>

## Common Use Cases

### 1. ML Pipeline Tracking

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="ml_pipeline_tracking.py"
    from handit_service import tracker
    from typing import Dict, Any, List
    import logging

    # ML pipeline tracking with detailed metrics
    class MLPipeline:
        def __init__(self, pipeline_id: str):
            self.pipeline_id = pipeline_id

        async def process_data(
            self,
            input_data: Dict[str, Any]
        ) -> Dict[str, Any]:
            """Process data through ML pipeline."""
            try:
                # Track input data
                tracker.capture_model(
                    model_id=f"{self.pipeline_id}-input",
                    request_body=input_data,
                    response_body=None
                )

                # Process data
                processed_data = self._process(input_data)
                
                # Track processing results
                tracker.capture_model(
                    model_id=f"{self.pipeline_id}-output",
                    request_body=input_data,
                    response_body=processed_data
                )

                return processed_data
            except Exception as e:
                # Track error
                tracker.capture_model(
                    model_id=f"{self.pipeline_id}-error",
                    request_body=input_data,
                    response_body={
                        "error": str(e),
                        "stack": getattr(e, '__traceback__', 'No stack trace')
                    }
                )
                raise

        def _process(self, data: Dict[str, Any]) -> Dict[str, Any]:
            """Process data through pipeline steps."""
            # Implementation details
            pass

    # Usage
    async def main():
        pipeline = MLPipeline("recommendation-v1")
        result = await pipeline.process_data({
            "user_id": 123,
            "preferences": ["action", "comedy"]
        })
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="ml_pipeline_tracking.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // ML pipeline tracking with detailed metrics
    class MLPipeline {
        constructor(pipelineId) {
            this.pipelineId = pipelineId;
        }

        async processData(inputData) {
            // Process data through ML pipeline
            try {
                // Track input data
                await captureModel({
                    modelId: `${this.pipelineId}-input`,
                    requestBody: inputData,
                    responseBody: null
                });

                // Process data
                const processedData = this._process(inputData);
                
                // Track processing results
                await captureModel({
                    modelId: `${this.pipelineId}-output`,
                    requestBody: inputData,
                    responseBody: processedData
                });

                return processedData;
            } catch (error) {
                // Track error
                await captureModel({
                    modelId: `${this.pipelineId}-error`,
                    requestBody: inputData,
                    responseBody: {
                        error: error.message,
                        stack: error.stack || 'No stack trace'
                    }
                });
                throw error;
            }
        }

        _process(data) {
            // Process data through pipeline steps
            // Implementation details
        }
    }

    // Usage
    const main = async () => {
        const pipeline = new MLPipeline('recommendation-v1');
        const result = await pipeline.processData({
            userId: 123,
            preferences: ['action', 'comedy']
        });
    };
    ```
  </Tabs.Tab>
</Tabs>

### 2. Batch Processing Tracking

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="batch_tracking.py"
    from handit_service import tracker
    from typing import List, Dict, Any
    import logging

    # Batch processing tracking with progress monitoring
    class BatchProcessor:
        def __init__(self, processor_id: str):
            self.processor_id = processor_id

        async def process_batch(
            self,
            items: List[Dict[str, Any]],
            batch_size: int = 100
        ) -> List[Dict[str, Any]]:
            """Process items in batches with tracking."""
            try:
                results = []
                total_batches = (len(items) + batch_size - 1) // batch_size

                for i in range(0, len(items), batch_size):
                    batch = items[i:i + batch_size]
                    batch_results = await self._process_batch(batch)
                    results.extend(batch_results)

                    # Track batch progress
                    tracker.capture_model(
                        model_id=f"{self.processor_id}-progress",
                        request_body={
                            "batch_number": i // batch_size + 1,
                            "total_batches": total_batches
                        },
                        response_body={
                            "processed_items": len(results),
                            "total_items": len(items)
                        }
                    )

                return results
            except Exception as e:
                logging.error(f"Batch processing error: {str(e)}")
                raise

        async def _process_batch(
            self,
            batch: List[Dict[str, Any]]
        ) -> List[Dict[str, Any]]:
            """Process a single batch of items."""
            # Implementation details
            pass

    # Usage
    async def main():
        processor = BatchProcessor("data-processor")
        items = [{"id": i} for i in range(1000)]
        results = await processor.process_batch(items)
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="batch_tracking.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // Batch processing tracking with progress monitoring
    class BatchProcessor {
        constructor(processorId) {
            this.processorId = processorId;
        }

        async processBatch(items, batchSize = 100) {
            // Process items in batches with tracking
            try {
                const results = [];
                const totalBatches = Math.ceil(items.length / batchSize);

                for (let i = 0; i < items.length; i += batchSize) {
                    const batch = items.slice(i, i + batchSize);
                    const batchResults = await this._processBatch(batch);
                    results.push(...batchResults);

                    // Track batch progress
                    await captureModel({
                        modelId: `${this.processorId}-progress`,
                        requestBody: {
                            batchNumber: Math.floor(i / batchSize) + 1,
                            totalBatches
                        },
                        responseBody: {
                            processedItems: results.length,
                            totalItems: items.length
                        }
                    });
                }

                return results;
            } catch (error) {
                logger.error(`Batch processing error: ${error.message}`);
                throw error;
            }
        }

        async _processBatch(batch) {
            // Process a single batch of items
            // Implementation details
        }
    }

    // Usage
    const main = async () => {
        const processor = new BatchProcessor('data-processor');
        const items = Array.from({ length: 1000 }, (_, i) => ({ id: i }));
        const results = await processor.processBatch(items);
    };
    ```
  </Tabs.Tab>
</Tabs>

### 3. Custom Metrics Tracking

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="metrics_tracking.py"
    from handit_service import tracker
    from typing import Dict, Any
    import time
    import logging

    # Custom metrics tracking with timing
    class MetricsTracker:
        def __init__(self, tracker_id: str):
            self.tracker_id = tracker_id
            self.metrics: Dict[str, Any] = {}

        async def track_operation(
            self,
            operation: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            """Track operation with timing and metrics."""
            try:
                start_time = time.time()
                result = await self._execute_operation(operation, data)
                end_time = time.time()

                # Track operation metrics
                metrics = {
                    "execution_time": end_time - start_time,
                    "operation": operation,
                    "status": "success"
                }
                
                tracker.capture_model(
                    model_id=f"{self.tracker_id}-metrics",
                    request_body={
                        "operation": operation,
                        "data": data
                    },
                    response_body=metrics
                )

                return result
            except Exception as e:
                # Track error metrics
                tracker.capture_model(
                    model_id=f"{self.tracker_id}-error",
                    request_body={
                        "operation": operation,
                        "data": data
                    },
                    response_body={
                        "error": str(e),
                        "status": "error"
                    }
                )
                raise

        async def _execute_operation(
            self,
            operation: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            """Execute the tracked operation."""
            # Implementation details
            pass

    # Usage
    async def main():
        tracker = MetricsTracker("custom-metrics")
        result = await tracker.track_operation(
            "data-processing",
            {"input": "test"}
        )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="metrics_tracking.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // Custom metrics tracking with timing
    class MetricsTracker {
        constructor(trackerId) {
            this.trackerId = trackerId;
            this.metrics = {};
        }

        async trackOperation(operation, data) {
            // Track operation with timing and metrics
            try {
                const startTime = Date.now();
                const result = await this._executeOperation(operation, data);
                const endTime = Date.now();

                // Track operation metrics
                const metrics = {
                    executionTime: endTime - startTime,
                    operation,
                    status: 'success'
                };
                
                await captureModel({
                    modelId: `${this.trackerId}-metrics`,
                    requestBody: {
                        operation,
                        data
                    },
                    responseBody: metrics
                });

                return result;
            } catch (error) {
                // Track error metrics
                await captureModel({
                    modelId: `${this.trackerId}-error`,
                    requestBody: {
                        operation,
                        data
                    },
                    responseBody: {
                        error: error.message,
                        status: 'error'
                    }
                });
                throw error;
            }
        }

        async _executeOperation(operation, data) {
            // Execute the tracked operation
            // Implementation details
        }
    }

    // Usage
    const main = async () => {
        const tracker = new MetricsTracker('custom-metrics');
        const result = await tracker.trackOperation(
            'data-processing',
            { input: 'test' }
        );
    };
    ```
  </Tabs.Tab>
</Tabs>

## Best Practices

1. **Event Identification**
   - Use meaningful event IDs
   - Include context information
   - Track related events together

2. **Data Management**
   - Sanitize sensitive data
   - Structure data consistently
   - Handle large payloads

3. **Error Handling**
   - Track error cases
   - Include error context
   - Maintain error history

4. **Performance Monitoring**
   - Track execution time
   - Monitor resource usage
   - Identify bottlenecks

<Callout type="warning">
  Always implement proper error handling and data sanitization when using Manual Capture to ensure you're tracking the right information securely.
</Callout>

## Advanced Usage

### 1. Custom Event Tracking

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="event_tracking.py"
    from handit_service import tracker
    from typing import Dict, Any
    import logging

    # Custom event tracking with context
    class EventTracker:
        def __init__(self, tracker_id: str):
            self.tracker_id = tracker_id

        async def track_event(
            self,
            event_type: str,
            data: Dict[str, Any],
            context: Dict[str, Any] = None
        ) -> None:
            """Track custom event with context."""
            try:
                event_data = {
                    "type": event_type,
                    "data": data,
                    "context": context or {}
                }
                
                tracker.capture_model(
                    model_id=f"{self.tracker_id}-event",
                    request_body=event_data,
                    response_body={"status": "tracked"}
                )
            except Exception as e:
                logging.error(f"Event tracking error: {str(e)}")
                raise

    # Usage
    async def main():
        tracker = EventTracker("custom-events")
        await tracker.track_event(
            "user-action",
            {"action": "click", "target": "button"},
            {"user_id": 123, "session_id": "abc"}
        )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="event_tracking.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // Custom event tracking with context
    class EventTracker {
        constructor(trackerId) {
            this.trackerId = trackerId;
        }

        async trackEvent(eventType, data, context = null) {
            // Track custom event with context
            try {
                const eventData = {
                    type: eventType,
                    data,
                    context: context || {}
                };
                
                await captureModel({
                    modelId: `${this.trackerId}-event`,
                    requestBody: eventData,
                    responseBody: { status: 'tracked' }
                });
            } catch (error) {
                logger.error(`Event tracking error: ${error.message}`);
                throw error;
            }
        }
    }

    // Usage
    const main = async () => {
        const tracker = new EventTracker('custom-events');
        await tracker.trackEvent(
            'user-action',
            { action: 'click', target: 'button' },
            { userId: 123, sessionId: 'abc' }
        );
    };
    ```
  </Tabs.Tab>
</Tabs>

### 2. Chain Event Tracking

<Tabs items={['Python', 'JavaScript']}>
  <Tabs.Tab>
    ```python filename="chain_tracking.py"
    from handit_service import tracker
    from typing import List, Dict, Any
    import logging

    # Chain event tracking with dependencies
    class ChainTracker:
        def __init__(self, chain_id: str):
            self.chain_id = chain_id

        async def track_chain(
            self,
            events: List[Dict[str, Any]]
        ) -> List[Dict[str, Any]]:
            """Track chain of related events."""
            try:
                results = []
                for i, event in enumerate(events):
                    # Track individual event
                    tracker.capture_model(
                        model_id=f"{self.chain_id}-event-{i}",
                        request_body=event,
                        response_body={"status": "processed"}
                    )
                    results.append(event)

                    # Track chain progress
                    tracker.capture_model(
                        model_id=f"{self.chain_id}-progress",
                        request_body={
                            "event_index": i,
                            "total_events": len(events)
                        },
                        response_body={
                            "processed_events": i + 1,
                            "remaining_events": len(events) - (i + 1)
                        }
                    )

                return results
            except Exception as e:
                logging.error(f"Chain tracking error: {str(e)}")
                raise

    # Usage
    async def main():
        tracker = ChainTracker("event-chain")
        events = [
            {"type": "start", "data": {"id": 1}},
            {"type": "process", "data": {"id": 1}},
            {"type": "complete", "data": {"id": 1}}
        ]
        results = await tracker.track_chain(events)
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript filename="chain_tracking.js"
    const { captureModel } = require('handit-service');
    const logger = require('./logger');

    // Chain event tracking with dependencies
    class ChainTracker {
        constructor(chainId) {
            this.chainId = chainId;
        }

        async trackChain(events) {
            // Track chain of related events
            try {
                const results = [];
                for (let i = 0; i < events.length; i++) {
                    const event = events[i];
                    
                    // Track individual event
                    await captureModel({
                        modelId: `${this.chainId}-event-${i}`,
                        requestBody: event,
                        responseBody: { status: 'processed' }
                    });
                    results.push(event);

                    // Track chain progress
                    await captureModel({
                        modelId: `${this.chainId}-progress`,
                        requestBody: {
                            eventIndex: i,
                            totalEvents: events.length
                        },
                        responseBody: {
                            processedEvents: i + 1,
                            remainingEvents: events.length - (i + 1)
                        }
                    });
                }

                return results;
            } catch (error) {
                logger.error(`Chain tracking error: ${error.message}`);
                throw error;
            }
        }
    }

    // Usage
    const main = async () => {
        const tracker = new ChainTracker('event-chain');
        const events = [
            { type: 'start', data: { id: 1 } },
            { type: 'process', data: { id: 1 } },
            { type: 'complete', data: { id: 1 } }
        ];
        const results = await tracker.trackChain(events);
    };
    ```
  </Tabs.Tab>
</Tabs>

<Callout type="info">
  Manual Capture provides flexible tracking capabilities for custom events and operations, helping you monitor and debug your application effectively.
</Callout>

<Callout type="success">
  By implementing Manual Capture in your application, you can gain valuable insights into custom operations and optimize their performance.
</Callout>
