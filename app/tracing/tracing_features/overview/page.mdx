---
title: 'Tracing Features Overview'
sidebarTitle: 'Overview'
---

import { Callout } from "nextra/components"
import { Steps } from "nextra/components"
import { Tabs } from "nextra/components"
import { Cards } from 'nextra/components'

# Tracing Features Overview

> **Transform your AI agents from black boxes to fully observable systems.** Handit's tracing features provide complete visibility into every operation, from high-level agent workflows to individual LLM calls and tool executions.

Comprehensive tracing enables your autonomous engineer to understand exactly how your AI works, identify issues when they occur, and generate targeted improvements based on real behavior patterns.

## Understanding AI Agent Observability

AI agents are complex systems that orchestrate multiple operations—they make decisions, call language models, execute tools, and chain operations together. Without proper observability, debugging issues or optimizing performance becomes nearly impossible.

**Handit provides three complementary types of tracing** that work together to give you complete visibility into your AI's behavior:

**Agent Tracing** captures the big picture—your complete agent workflow from start to finish. This is like having a flight recorder for your entire AI system.

**LLM Node Tracing** provides detailed insight into every language model interaction, showing exactly what prompts were sent, what responses were received, and how your AI uses language models.

**Tool Tracing** monitors every function and API call your AI makes, capturing parameters, results, timing, and errors to help you understand when external operations cause problems.

<Callout type="info">
  These three tracing types work together automatically. When you trace an agent workflow, all LLM calls and tool executions within that workflow are captured with full context and linked together.
</Callout>

## Agent Tracing: The Complete Picture

Agent tracing wraps your entire AI workflow, creating a comprehensive record of everything your agent does to process a request. This is typically what you'll apply to your main agent functions or API endpoints.

**What gets captured**: The complete execution timeline from first input to final output, all child operations automatically linked together, error propagation through your system, and overall performance metrics.

**Why it matters**: Agent tracing gives your autonomous engineer the big picture view it needs to understand how your AI system operates as a whole. When issues occur, it can see the complete context and understand how different components interact.

<Tabs items={['Python', 'JavaScript']}>
<Tabs.Tab>
```python filename="process_customer_request.py"
@tracker.start_agent_tracing()
async def process_customer_request(request):
    # Everything inside here is automatically traced
    intent = await classify_intent(request)
    context = await search_knowledge_base(intent)
    response = await generate_response(context)
    return response
```
</Tabs.Tab>
<Tabs.Tab>
```javascript filename="processCustomerRequest.js"
const processCustomerRequest = startAgentTracing(async (request) => {
    // Everything inside here is automatically traced
    const intent = await classifyIntent(request);
    const context = await searchKnowledgeBase(intent);
    const response = await generateResponse(context);
    return response;
});
```
</Tabs.Tab>
</Tabs>

## LLM Node Tracing: Understanding AI Decisions

LLM node tracing captures every interaction with language models, providing the detailed insight your autonomous engineer needs to understand how your AI uses language models and where improvements might be needed.

**What gets captured**: Complete prompt history with every prompt and response recorded, performance metrics including response time and token usage, model parameters and settings, and detailed error information when calls fail.

**Why it matters**: Language model interactions are often the most critical and expensive part of AI systems. LLM node tracing helps your autonomous engineer understand prompt effectiveness, identify performance bottlenecks, and generate improvements to system prompts.

<Tabs items={['Python', 'JavaScript']}>
<Tabs.Tab>
```python filename="classify_intent.py"
@tracker.trace_agent_node("intent-classifier")
async def classify_intent(user_message):
    # LLM call is automatically captured with full context
    response = await llm.generate(f"Classify intent: {user_message}")
    return response
```
</Tabs.Tab>
<Tabs.Tab>
```javascript filename="classifyIntent.js"
const classifyIntent = traceAgentNode("intent-classifier", async (userMessage) => {
    // LLM call is automatically captured with full context
    const response = await llm.generate(`Classify intent: ${userMessage}`);
    return response;
});
```
</Tabs.Tab>
</Tabs>

## Tool Tracing: Monitoring External Operations

Tool tracing monitors every function and API call your AI makes, helping your autonomous engineer understand when external operations cause problems or perform poorly.

**What gets captured**: Function parameters and return values, execution timing and performance data, error conditions and failure details, and API response codes and metadata.

**Why it matters**: Tools and external functions are common sources of AI system issues. Tool tracing helps your autonomous engineer identify when external operations are slow, unreliable, or returning unexpected data that affects your AI's performance.

<Tabs items={['Python', 'JavaScript']}>
<Tabs.Tab>
```python filename="search_knowledge_base.py"
@tracker.trace_tool("knowledge-search")
async def search_knowledge_base(query):
    # Tool execution is automatically captured
    results = await knowledge_api.search(query)
    return results
```
</Tabs.Tab>
<Tabs.Tab>
```javascript filename="searchKnowledgeBase.js"
const searchKnowledgeBase = traceTool("knowledge-search", async (query) => {
    // Tool execution is automatically captured
    const results = await knowledgeApi.search(query);
    return results;
});
```
</Tabs.Tab>
</Tabs>

## How Tracing Enables Autonomous Improvement

Comprehensive tracing provides the foundation that enables your autonomous engineer to work effectively:

**Pattern Recognition**: By analyzing thousands of traces, your autonomous engineer identifies patterns in successful and failed interactions that would be impossible to spot manually.

**Root Cause Analysis**: When issues occur, detailed trace data helps your autonomous engineer understand exactly what went wrong—whether it's a prompt issue, tool failure, or logic error.

**Performance Optimization**: Timing data from traces helps your autonomous engineer identify bottlenecks and generate improvements that address actual performance issues.

**Fix Validation**: Historical trace data allows your autonomous engineer to test potential improvements against real past interactions, ensuring fixes actually solve problems.

## Real-World Benefits

Teams using comprehensive tracing report significant improvements in their AI development and operations:

**Faster Debugging**: Issues that used to take days to diagnose get resolved in hours because teams can see exactly what happened in production.

**Better Performance**: Detailed timing and performance data enables targeted optimizations that actually improve user experience.

**Confident Deployments**: Understanding exactly how changes affect AI behavior enables teams to deploy improvements with confidence.

**Autonomous Improvement**: Comprehensive trace data enables autonomous engineers to generate meaningful improvements rather than generic fixes.

## Getting Started with Tracing

Ready to make your AI fully observable?

<Cards.Card title="Main Quickstart - Includes Tracing" href="/quickstart" arrow />
<Cards.Card title="Tracing Setup Guide" href="/tracing/quickstart" arrow />

**Advanced Resources:**
- [Agent Tracing Details](/tracing/tracing_features/agent)
- [LLM Node Tracing](/tracing/tracing_features/llm_node) 
- [Tool Tracing](/tracing/tracing_features/tool)

<Callout type="success">
  **Start with agent tracing** for your main AI workflows. LLM node and tool tracing will be captured automatically within those workflows, giving you complete observability with minimal setup.
</Callout>

Transform your AI from a mysterious black box into a fully observable system that your autonomous engineer can continuously monitor and improve.