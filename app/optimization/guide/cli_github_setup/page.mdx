---
title: 'Connect GitHub for Autonomous AI Fixes'
sidebarTitle: 'CLI & GitHub Setup'
---

import { Callout } from "nextra/components"
import { Steps } from "nextra/components"

# Connect GitHub for Autonomous AI Fixes

> **Transform Handit into your autonomous AI engineer.** Connect GitHub so Handit can automatically detect issues, create fixes, and ship pull requests with improved AI codeâ€”all while you focus on building features.

<Callout type="info">
  **Prerequisites**: You need the Handit CLI installed and your AI running with Handit evaluation. If you haven't set up Handit yet, start with our [Main Quickstart](/quickstart).
</Callout>

## Why Connect GitHub?

Imagine having a dedicated engineer whose only job is to monitor your AI and fix issues as they arise. That's exactly what connecting GitHub to Handit gives youâ€”an autonomous team member that works 24/7 to keep your AI performing at its best.

Without GitHub integration, Handit can detect issues and generate fixes, but you still need to manually implement them. With GitHub connected, Handit becomes truly autonomous: it detects problems, creates proven solutions, and delivers them as pull requests ready for your review and deployment.

**The transformation is remarkable.** Instead of waking up to alerts about AI quality issues, you wake up to pull requests with validated fixes. Instead of spending your weekends debugging prompts, you spend five minutes reviewing and merging improvements that have already been tested on real data.

## Setting Up Your Autonomous Engineer

Getting your autonomous engineer connected to GitHub takes just a few minutes:

```bash filename="terminal"
handit-cli github
```

The CLI will guide you through an interactive setup process. First, it helps you select which repository contains your AI code and confirms you have the necessary permissions to install GitHub apps.

Next, the CLI opens your browser to install the Handit GitHub app on your repository. This app allows your autonomous engineer to create pull requests, read your code structure, and update prompt files when fixes are validated.

Finally, the setup configures which of your AI components should trigger automated pull requests and sets quality thresholds to ensure only meaningful improvements generate PRs.

<Callout type="tip">
  **Repository Access**: You'll need admin access to install the GitHub app. If you don't have admin permissions, ask a repository administrator to run the setup or temporarily grant you the necessary permissions.
</Callout>

## How Your Autonomous Engineer Creates Pull Requests

Once connected, your autonomous engineer operates with impressive sophistication. When it detects a quality issueâ€”say, your customer service AI's empathy scores drop significantlyâ€”it doesn't just alert you. Instead, it investigates.

**Analysis and Fix Generation**: Your autonomous engineer analyzes recent interactions to understand what changed. Maybe customer complaints became more complex, or your system prompt doesn't handle frustrated users well. Based on this analysis, it generates an improved prompt that specifically addresses the identified issues.

**Rigorous Testing**: Before creating any pull request, your autonomous engineer tests its fix thoroughly. It runs hundreds of real user interactions through both your current prompt and the improved version, measuring the difference in quality scores. Only when it achieves statistical confidence that the fix genuinely improves performance does it proceed.

**Professional Pull Requests**: When a fix is validated, your autonomous engineer creates a detailed pull request that explains what was wrong, how the fix addresses it, and provides concrete evidence of improvement. The PR includes before/after metrics, example interactions that improved, and clear explanations of the changes made.

## What Your Pull Requests Look Like

Here's an example of what you'll receive when your autonomous engineer detects and fixes an issue:

```markdown
## ðŸ¤– Autonomous AI Fix: Improve Customer Service Empathy

### Issue Detected
Empathy scores dropped from 4.2/5.0 to 3.7/5.0 over the past week, 
causing a 15% decrease in customer satisfaction scores.

### Root Cause Analysis  
The system prompt lacks emotional context for handling frustrated customers. 
Recent interactions show the AI providing technically correct but emotionally 
tone-deaf responses to upset users.

### Fix Applied
Updated `src/agents/customer_service/system_prompt.py` to include:
- Emotional awareness guidelines for frustrated customers
- Specific language patterns for empathetic responses
- Context preservation for emotional state throughout conversations

### Validation Results
- Empathy Score: 3.7/5.0 â†’ 4.6/5.0 (+24% improvement)
- Customer Satisfaction: 78% â†’ 89% (+11% improvement)  
- Statistical Confidence: 95% (tested on 500 real interactions)
- No negative impact on response time or accuracy

### Files Changed
- `src/agents/customer_service/system_prompt.py`

Ready to merge when you approve!
```

This level of detail means you can quickly understand the change, verify it makes sense for your use case, and merge with confidence.

## Integration with Your Workflow

Your autonomous engineer seamlessly integrates with your existing development process. Pull requests from your autonomous engineer work exactly like those from human teammatesâ€”they trigger your CI/CD pipelines, run your tests, and follow your code review requirements.

**Repository Structure Flexibility**: Your autonomous engineer adapts to however you organize your code. Whether your prompts are in separate files, embedded in your application code, or part of a larger monorepo, it learns your structure and makes appropriate updates.

**CI/CD Compatibility**: The pull requests work with GitHub Actions, CircleCI, Jenkins, or any other CI/CD system you use. You can add specific validation steps for AI changes, require certain team members to review AI improvements, or automatically deploy changes that pass your tests.

**Branch Protection**: Your autonomous engineer respects your branch protection rules. If you require reviews before merging to main, it will create PRs that wait for approval. If you have required status checks, the PRs will wait for those to pass.

## Monitoring Your Autonomous Engineer

You can track your autonomous engineer's work through several channels:

**GitHub Activity**: All pull requests appear in your normal GitHub workflow. You'll see them in your PR list, receive notifications according to your GitHub settings, and can review them using GitHub's standard interface.

**Handit Dashboard**: The Agent Performance section shows when issues are detected and fixes are generated. You can see the quality trends that triggered each improvement and track the impact of merged changes over time.

**Release Hub**: Provides detailed analysis of each fix, including the A/B test results that validated the improvement. This gives you full transparency into how your autonomous engineer makes decisions and ensures you understand the reasoning behind each change.

## Security and Permissions

Your autonomous engineer operates with carefully limited permissions designed to enable its work while maintaining security:

**Repository Access**: The GitHub app can read your repository structure and create pull requests, but it cannot merge changes or access sensitive information like secrets or environment variables.

**File Modifications**: Your autonomous engineer only modifies prompt-related files that you've configured during setup. It cannot change application logic, dependencies, or configuration files beyond the specific AI prompts it's designed to improve.

**Review Requirements**: All changes go through your standard code review process. Your autonomous engineer cannot bypass branch protection rules or merge its own changesâ€”you maintain complete control over what goes into production.

## Advanced Configuration

Most teams find the default configuration works well, but you can customize your autonomous engineer's behavior through the Handit dashboard:

**Quality Thresholds**: Adjust how significant an improvement must be before a pull request is created. Higher thresholds mean fewer but more impactful PRs, while lower thresholds catch smaller issues more quickly.

**PR Timing**: Choose whether to create pull requests immediately when fixes are validated or batch multiple improvements together for less frequent but more comprehensive updates.

**Repository Settings**: Specify which files your autonomous engineer should monitor and update, set target branches for pull requests, and configure integration with your specific CI/CD requirements.

## Troubleshooting

**Setup Issues**: If the GitHub integration fails during setup, ensure you have admin access to the repository and that your organization allows third-party GitHub apps. Re-running `handit-cli github` will guide you through any missing steps.

**Missing Pull Requests**: If you don't see pull requests after several days, it likely means your AI is performing well and no significant issues have been detected. Check your Agent Performance dashboard to confirm your quality metrics are stable.

**Permission Problems**: If pull requests fail to create, verify the Handit GitHub app still has the necessary permissions in your repository settings. Organization-level security policies sometimes change app permissions after installation.

For additional help, our [support team](/more/contact) can assist with specific configuration questions or integration challenges.

## Your Autonomous Engineer is Ready

<Callout type="success">
  **Congratulations!** Your AI now has a dedicated autonomous engineer working 24/7. It will detect issues, write fixes, test them on real data, and create pull requestsâ€”all while you sleep.
</Callout>

**What happens next**: Your autonomous engineer begins monitoring your AI immediately. When it detects quality issues, generates fixes, and validates improvements, you'll receive pull requests with proven enhancements ready for review and deployment.

**No more 2 AM alerts. No more manual prompt engineering. Just wake up to better AI.**

Your days of being on-call for AI quality issues are over. Focus on building great products while your autonomous engineer handles the continuous improvement of your AI systems.