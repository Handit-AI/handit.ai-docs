---
title: 'Python SDK'
sidebarTitle: 'Python SDK'
---

import { Callout } from "nextra/components"
import { Steps } from "nextra/components"
import { Tabs } from "nextra/components"

# Python SDK

The Handit.ai Python SDK provides comprehensive tracking and monitoring capabilities for your AI applications. This guide will help you integrate and use the SDK effectively.

<Callout type="info">
  The SDK automatically tracks function executions, model calls, and tool usage, providing detailed insights into your AI application's behavior.
</Callout>

## Installation

```bash
pip install handit
```

## Quick Start

```python
from handit_service import tracker

# Configure the tracker
tracker.config(api_key="your-api-key")

# Start tracking your agent
@tracker.start_agent_tracing(key="my-agent")
async def my_agent(input_data):
    # Your agent logic here
    pass
```

## Core Features

### 1. Agent Tracing

Track complete agent execution flows with automatic context management.

```python
from handit_service import tracker

@tracker.start_agent_tracing(key="invoice-processor")
async def process_invoice(invoice_data):
    # Your agent logic here
    result = await process_data(invoice_data)
    return result
```

### 2. Node Tracing

Track individual function executions within your agent.

```python
from handit_service import tracker

# For async functions
async def process_data(data):
    result = await tracker.trace_agent_node_func(
        process_item,
        data,
        key="data-processor"
    )
    return result

# For sync functions
def validate_data(data):
    result = tracker.trace_agent_node_func_sync(
        validate_item,
        data,
        key="data-validator"
    )
    return result
```

### 3. Model Tracking

Track AI model interactions with detailed input/output logging.

```python
from handit_service import tracker
from langchain.chat_models import ChatOpenAI

# Initialize and track a model
model = ChatOpenAI()
tracked_model = tracker.track_model(model, model_id="gpt-4")

# Use the tracked model
response = await tracked_model.agenerate(messages)
```

### 4. Tool Tracking

Monitor tool executions with comprehensive logging.

```python
from handit_service import tracker

# Track a custom tool
@tracker.trace_agent_node(key="search-tool")
async def search_documents(query):
    # Tool implementation
    results = await perform_search(query)
    return results
```

## Advanced Usage

### 1. Custom Event Tracking

Track custom events and operations.

```python
from handit_service import tracker

# Track a custom event
tracker.capture_model(
    model_id="custom-event",
    request_body={"user_id": 123},
    response_body={"status": "success"}
)
```

### 2. Batch Processing

Track batch operations with progress monitoring.

```python
from handit_service import tracker
from typing import List, Dict, Any

async def process_batch(items: List[Dict[str, Any]]):
    results = []
    for item in items:
        # Process and track each item
        result = await tracker.trace_agent_node_func(
            process_item,
            item,
            key="batch-processor"
        )
        results.append(result)
    return results
```

### 3. Error Handling

Comprehensive error tracking and logging.

```python
from handit_service import tracker
import logging

@tracker.trace_agent_node(key="error-handler")
async def handle_operation(data):
    try:
        result = await process_data(data)
        return result
    except Exception as e:
        # Error is automatically tracked
        logging.error(f"Operation failed: {str(e)}")
        raise
```

## Configuration

### 1. Basic Configuration

```python
from handit_service import tracker

# Configure with API key
tracker.config(api_key="your-api-key")

# Optional: Configure custom tracking URL
tracker.config(
    api_key="your-api-key",
    tracking_url="https://custom-tracking-url.com"
)
```

### 2. Environment Setup

Create a `handit_service.py` file for centralized configuration:

```python
# handit_service.py
from handit import HanditTracker

tracker = HanditTracker()
tracker.config(api_key="your-api-key")
```

## Best Practices

1. **Centralized Configuration**
   - Use a single `handit_service.py` file
   - Configure once at application startup
   - Share the tracker instance

2. **Agent Tracing**
   - Always wrap main agent functions
   - Use meaningful agent IDs
   - Include proper error handling

3. **Node Tracing**
   - Track all important functions
   - Use descriptive node IDs
   - Handle errors appropriately

4. **Data Management**
   - Sanitize sensitive data
   - Structure data consistently
   - Handle large payloads

<Callout type="warning">
  Always implement proper error handling and data sanitization when using the SDK to ensure secure and reliable tracking.
</Callout>

## Common Patterns

### 1. Agent with Multiple Nodes

```python
from handit_service import tracker

@tracker.start_agent_tracing(key="document-processor")
async def process_document(document):
    # Track document parsing
    parsed = await tracker.trace_agent_node_func(
        parse_document,
        document,
        key="document-parser"
    )
    
    # Track content extraction
    content = await tracker.trace_agent_node_func(
        extract_content,
        parsed,
        key="content-extractor"
    )
    
    # Track summary generation
    summary = await tracker.trace_agent_node_func(
        generate_summary,
        content,
        key="summary-generator"
    )
    
    return summary
```

### 2. Model Chain Tracking

```python
from handit_service import tracker
from langchain.chat_models import ChatOpenAI
from langchain.embeddings import OpenAIEmbeddings

# Initialize and track models
chat_model = tracker.track_model(
    ChatOpenAI(),
    model_id="gpt-4"
)
embedding_model = tracker.track_model(
    OpenAIEmbeddings(),
    model_id="text-embedding"
)

# Use tracked models in chain
async def process_with_models(text):
    # Track embedding generation
    embedding = await tracker.trace_agent_node_func(
        embedding_model.aembed_query,
        text,
        key="embedding-generator"
    )
    
    # Track chat completion
    response = await tracker.trace_agent_node_func(
        chat_model.agenerate,
        [{"role": "user", "content": text}],
        key="chat-completion"
    )
    
    return response
```

### 3. Tool Integration

```python
from handit_service import tracker

# Track custom tool
@tracker.trace_agent_node(key="search-tool")
async def search_documents(query):
    try:
        results = await perform_search(query)
        return results
    except Exception as e:
        # Error is automatically tracked
        raise

# Track API tool
@tracker.trace_agent_node(key="api-tool")
async def call_external_api(endpoint, data):
    try:
        response = await make_api_call(endpoint, data)
        return response
    except Exception as e:
        # Error is automatically tracked
        raise
```

## Error Handling

### 1. Basic Error Handling

```python
from handit_service import tracker
import logging

@tracker.trace_agent_node(key="error-handler")
async def safe_operation(data):
    try:
        result = await process_data(data)
        return result
    except Exception as e:
        logging.error(f"Operation failed: {str(e)}")
        raise
```

### 2. Advanced Error Handling

```python
from handit_service import tracker
import logging
from typing import Optional, Dict, Any

class OperationError(Exception):
    pass

@tracker.trace_agent_node(key="advanced-handler")
async def handle_operation(
    data: Dict[str, Any],
    retry_count: int = 3
) -> Optional[Dict[str, Any]]:
    for attempt in range(retry_count):
        try:
            result = await process_data(data)
            return result
        except Exception as e:
            if attempt == retry_count - 1:
                logging.error(f"Operation failed after {retry_count} attempts: {str(e)}")
                raise OperationError(f"Failed to process data: {str(e)}")
            logging.warning(f"Attempt {attempt + 1} failed: {str(e)}")
```

## Performance Monitoring

### 1. Basic Performance Tracking

```python
from handit_service import tracker
import time
from typing import Dict, Any

@tracker.trace_agent_node(key="performance-tracker")
async def track_performance(operation: str, data: Dict[str, Any]):
    start_time = time.time()
    try:
        result = await process_data(data)
        execution_time = time.time() - start_time
        
        # Track performance metrics
        tracker.capture_model(
            model_id="performance-metrics",
            request_body={
                "operation": operation,
                "data": data
            },
            response_body={
                "execution_time": execution_time,
                "status": "success"
            }
        )
        
        return result
    except Exception as e:
        execution_time = time.time() - start_time
        
        # Track error metrics
        tracker.capture_model(
            model_id="performance-metrics",
            request_body={
                "operation": operation,
                "data": data
            },
            response_body={
                "execution_time": execution_time,
                "status": "error",
                "error": str(e)
            }
        )
        raise
```

### 2. Advanced Performance Monitoring

```python
from handit_service import tracker
import time
from typing import Dict, Any, List
import statistics

class PerformanceMonitor:
    def __init__(self, monitor_id: str):
        self.monitor_id = monitor_id
        self.metrics: List[float] = []

    @tracker.trace_agent_node(key="performance-monitor")
    async def track_operation(
        self,
        operation: str,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        start_time = time.time()
        try:
            result = await process_data(data)
            execution_time = time.time() - start_time
            self.metrics.append(execution_time)
            
            # Calculate statistics
            stats = {
                "current": execution_time,
                "average": statistics.mean(self.metrics),
                "median": statistics.median(self.metrics),
                "min": min(self.metrics),
                "max": max(self.metrics)
            }
            
            # Track performance metrics
            tracker.capture_model(
                model_id=f"{self.monitor_id}-metrics",
                request_body={
                    "operation": operation,
                    "data": data
                },
                response_body={
                    "execution_time": execution_time,
                    "statistics": stats,
                    "status": "success"
                }
            )
            
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            self.metrics.append(execution_time)
            
            # Track error metrics
            tracker.capture_model(
                model_id=f"{self.monitor_id}-error",
                request_body={
                    "operation": operation,
                    "data": data
                },
                response_body={
                    "execution_time": execution_time,
                    "error": str(e),
                    "status": "error"
                }
            )
            raise
```

<Callout type="info">
  The SDK provides comprehensive tracking capabilities for your AI applications, helping you monitor performance and debug issues effectively.
</Callout>

<Callout type="success">
  By implementing the SDK in your application, you can gain valuable insights into your AI operations and optimize their performance.
</Callout>
